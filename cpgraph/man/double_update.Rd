% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/double_update.R
\name{double_update}
\alias{double_update}
\title{Double iteration of the split, fit and minimize procedure.}
\usage{
double_update(
  x,
  type = "mean",
  edge = 0.05,
  lambda_vec = NULL,
  length_lam = 50,
  lam_sep = 1.75,
  par = F,
  cv = 5,
  bic_const = 0.25,
  NumCores = 4,
  start_grid = 0.5,
  l_end = 2
)
}
\arguments{
\item{x}{an n by p matrix of observations.}

\item{type}{a string of characters denoting the detection type : "mean" or
"graph"}

\item{edge}{percentage of throaway data from the edges.}

\item{lambda_vec}{a grid of values of the regularization parameter to be used
for cross-validation.}

\item{length_lam}{length of grid.}

\item{lam_sep}{numeric value. Used in the regularizer grid if not provided by
the user.}

\item{par}{If TRUE parallelization of the lasso estimation is performed.}

\item{cv}{number of cross-validation folds.}

\item{bic_const}{penalty used in the BIC evaluation.}

\item{NumCores}{number of processor cores to be used}

\item{start_grid}{grid of values for the initial split location}

\item{l_end}{end value of the lambda sequence}
}
\value{
\item{upd1}{First estimate (sub-optimal)}
\item{upd2}{Second estimate (optimal)}
}
\description{
Finds the optimal estimator of the change point by applying
twice the split, fit and minimize procedure on a sequence of observations.
}
\details{
This function is a double application of the split, fit and
minimize procedure.
If the user inputs \code{start_grid} as a vector of values then a split value
is chosen that has minimal LS cost with parameters
fitted at this split value. The parameters are obtained using the
\code{glmnet} regularization path with parameters specified in
\code{lambda_vec}.
If \code{lambda_vec} is omitted the path is set to
\deqn{seq(lam_sep * ( sqrt( log(max(p,n) ) / n ), l_end, length.out = length_lam)}
If \code{par=TRUE} the coefficient estimation is done in parallel using
the library \code{parallel} with the number of CPU cores
set to \code{NumCores}.
}
\examples{
p = 50; n = 225; t0 = 0.2
params = gen_param(p = p, reg_param = TRUE)
sig1 = params$pre_cov; sig2 = params$post_cov
image(as.matrix(sig1));image(as.matrix(sig2))
#generate data
x=gen.data(n = n, p = p, t0 = t0, sig1, sig2)$data
params$jump_size
params$normalized_jump

#parallel
stp = proc.time()
mod_full = double_update(x, par = TRUE)
proc.time() - stp
mod_full

#sequential
stp = proc.time()
mod_full = double_update(x)
proc.time() - stp
mod_full
}
\author{
Konstantinos Tsampourakis <kostas.tsampourakis@gmail.com>
}
