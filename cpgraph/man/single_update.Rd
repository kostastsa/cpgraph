% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/single_update.R
\name{single_update}
\alias{single_update}
\title{Single iteration of the split, fit and minimize procedure.}
\usage{
single_update(
  x,
  type = "mean",
  edge = 0.05,
  lambda_vec = NULL,
  length_lam = 50,
  lam_sep = 1.75,
  par = F,
  cv = 5,
  bic_const = 0.25,
  NumCores = 4,
  start_grid = 0.5,
  l_end = 2
)
}
\arguments{
\item{x}{an n by p matrix of observations.}

\item{type}{a string of characters denoting the detection type : "mean" or
"graph"}

\item{edge}{percentage of throaway data from the edges.}

\item{lambda_vec}{a grid of values of the regularization parameter to be used
for cross-validation.}

\item{length_lam}{length of grid.}

\item{lam_sep}{numeric value. Used in the regularizer grid if not provided by
the user.}

\item{par}{If TRUE parallelization of the lasso estimation is performed.}

\item{cv}{number of cross-validation folds.}

\item{bic_const}{penalty used in the BIC evaluation.}

\item{NumCores}{number of processor cores to be used}

\item{start_grid}{grid of values for the initial split location}

\item{l_end}{end value of the lambda sequence}
}
\value{
\item{est}{numerical value in (0,1]. If est = 1 then no
change-point was detected.
If est<1 the value corresponds to the LS minimizer.}
\item{tau_check}{the value used for the initial data split.}
\item{loss.grid}{LS cost values along the time grid.}
}
\description{
Finds the minimizer of the least squares (LS) cost given a data
matrix and initial split location or grid thereof.
It applies an information criterion with user-chosen penalty.
It returns the estimated value with the corresponding cost as well as the
initial split location.
}
\details{
This function is a single application of the split, fit and minimize
procedure. The procedure initially splits the data at an initial estimate
\code{start_grid}. Then in each segment it fits a sequence of linear models
to estimate precision matrices for each segment. Finally it minimizes
the least squares cost, that is defined throught these estimates, to obtain
an updated estimate of the change point. If the user inputs \code{start_grid}
as a vector of values then a split value is chosen that has minimal LS cost
with parameters fitted at this split value. The parameters are obtained using
the \code{glmnet} regularization path with parameters specified in
\code{lambda_vec}. If \code{lambda_vec} is omitted the path is set to
\deqn{seq(lam_sep * ( sqrt( log(max(p, n) ) / n ), l_end, length.out = length_lam)}
If \code{par=TRUE} the coefficient estimation is done in parallel using the
library \code{parallel} with the number of CPU cores set to \code{NumCores}.
}
\examples{
p = 50; n = 300; t0 = 0.2
params = gen_param(p = p, reg_param = TRUE)
sig1 = params$pre_cov; sig2 = params$post_cov
image(sig1); image(sig2)
# Generate data
x = gen_data(n = n, p = p, t0 = t0, sig1, sig2)$data
params$jump_size
params$normalized_jump

# Sequential
mod = single_update(x)
plot(mod$loss_grid,type="l")
mod$est

# Parallel
mod = single_update(x, par = T)
plot(mod$loss_grid, type="l")
mod$est

# Parallel and search grid
mod = single_update(x, par = T, start_grid = c(0.3,0.6))
plot(mod$loss_grid, type="l")
mod$est
}
\author{
Konstantinos Tsampourakis <kostas.tsampourakis@gmail.com>
}
